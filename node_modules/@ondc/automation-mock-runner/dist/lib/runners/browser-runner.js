"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserRunner = void 0;
const code_validator_1 = require("../validators/code-validator");
const worker_factory_1 = require("../worker/worker-factory");
class BrowserRunner {
    constructor() {
        this.worker = null;
        this.executionId = 0;
        this.pendingExecutions = new Map();
        this.initWorker();
    }
    initWorker() {
        if (this.worker) {
            this.worker.terminate();
        }
        this.worker = worker_factory_1.WorkerFactory.createCodeRunnerWorker();
        this.worker.addEventListener("message", (event) => {
            const { id, success, result, error, logs, executionTime } = event.data;
            const pending = this.pendingExecutions.get(id);
            if (pending) {
                clearTimeout(pending.timeout);
                this.pendingExecutions.delete(id);
                pending.resolve({
                    timestamp: new Date().toISOString(),
                    success,
                    result,
                    error,
                    logs,
                    executionTime,
                    validation: { isValid: true, errors: [], warnings: [] },
                });
            }
        });
        this.worker.addEventListener("error", (error) => {
            console.error("Worker error:", error);
            this.initWorker();
        });
    }
    async execute(functionBody, schema, args) {
        const validation = code_validator_1.CodeValidator.validate(functionBody, schema);
        if (!validation.isValid || !validation.wrappedCode) {
            return {
                success: false,
                timestamp: new Date().toISOString(),
                error: {
                    message: validation.errors.join("\n"),
                    name: "ValidationError",
                },
                logs: [],
                validation,
            };
        }
        // Execute wrapped code in worker
        return new Promise((resolve) => {
            const id = ++this.executionId;
            const timeout = schema.timeout || 5000;
            const timeoutId = setTimeout(() => {
                this.pendingExecutions.delete(id);
                resolve({
                    success: false,
                    timestamp: new Date().toISOString(),
                    error: {
                        message: `Execution timeout after ${timeout}ms`,
                        name: "TimeoutError",
                    },
                    logs: [],
                    validation,
                });
                this.initWorker();
            }, timeout); // Type assertion for compatibility
            this.pendingExecutions.set(id, {
                resolve: (result) => {
                    resolve({ ...result, validation });
                },
                timeout: timeoutId,
            });
            this.worker?.postMessage({
                id,
                code: validation.wrappedCode,
                functionName: schema.name,
                args,
            });
        });
    }
    terminate() {
        this.worker?.terminate();
        this.worker = null;
    }
}
exports.BrowserRunner = BrowserRunner;
