"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRunner = void 0;
const runner_factory_1 = require("./runners/runner-factory");
const validateConfig_1 = require("./utils/validateConfig");
const logger_1 = require("./utils/logger");
const errors_1 = require("./utils/errors");
const jsonpath_1 = __importDefault(require("jsonpath"));
const function_registry_1 = require("./constants/function-registry");
const uuid_1 = require("uuid");
class MockRunner {
    constructor(config, skipValidation = false) {
        this.logger = logger_1.Logger.getInstance();
        if (!skipValidation) {
            // Validate config on construction
            const validation = (0, validateConfig_1.validateConfigWithErrors)(config);
            if (!validation.success) {
                const errorMessages = validation.errors?.map((err) => `${err.path.join(".")}: ${err.message}`) || [];
                this.logger.error("Invalid configuration provided", {
                    errors: errorMessages,
                });
                throw new errors_1.ConfigurationError(`Configuration validation failed: ${errorMessages.join(", ")}`, { errors: errorMessages });
            }
        }
        else {
            this.logger.warn("Skipping configuration validation as per request");
        }
        this.config = config;
        this.logger.info("MockRunner initialized successfully", {
            domain: config.meta.domain,
            version: config.meta.version,
            flowId: config.meta.flowId,
            stepsCount: config.steps.length,
        });
    }
    getRunnerInstance() {
        this.logger.debug("Getting code runner instance");
        if (!this.runner) {
            this.runner = runner_factory_1.RunnerFactory.createRunner({}, this.logger);
        }
        this.logger.debug("Code runner instance obtained successfully: " + this.runner.toString());
        return this.runner;
    }
    getConfig() {
        return this.config;
    }
    validateConfig() {
        const res = (0, validateConfig_1.validateConfigWithErrors)(this.config);
        return res;
    }
    async runGeneratePayload(actionId, inputs = {}) {
        const executionId = this.logger.createExecutionContext(actionId);
        const startTime = Date.now();
        try {
            this.logger.logExecution(executionId, "Starting payload generation", {
                actionId,
                inputKeys: Object.keys(inputs),
            });
            const step = this.config.steps.find((s) => s.action_id === actionId);
            if (!step) {
                const availableActions = this.config.steps.map((s) => s.action_id);
                throw new errors_1.ActionNotFoundError(actionId, availableActions);
            }
            const index = this.config.steps.findIndex((s) => s.action_id === actionId);
            // Deep clone to avoid mutations
            const defaultPayload = JSON.parse(JSON.stringify(step.mock.defaultPayload));
            const sessionData = await this.getSessionDataUpToStep(index);
            // Validate inputs against schema if provided
            if (step.mock.inputs?.jsonSchema && Object.keys(inputs).length > 0) {
                // TODO: Add JSON schema validation for inputs
                this.logger.debug("Input validation needed", {
                    actionId,
                    inputSchema: step.mock.inputs.jsonSchema,
                });
            }
            sessionData.user_inputs = inputs;
            const context = this.generateContext(step.action_id, step.api);
            defaultPayload.context = context;
            const schema = (0, function_registry_1.getFunctionSchema)("generate");
            const code = MockRunner.decodeBase64(step.mock.generate);
            let helperLib = "";
            try {
                helperLib = MockRunner.decodeBase64(this.config.helperLib || "");
            }
            catch (e) {
                this.logger.error("Failed to decode helper library", { actionId }, e);
                helperLib = "";
            }
            // Combine helper library and main code
            const fullCode = helperLib + "\n" + code;
            const result = await this.getRunnerInstance().execute(fullCode, schema, [
                defaultPayload,
                sessionData,
            ]);
            const executionTime = Date.now() - startTime;
            this.logger.logExecution(executionId, "Payload generation completed", {
                actionId,
                success: result.success,
                output: result.result,
                executionTime,
            });
            return result;
        }
        catch (error) {
            const executionTime = Date.now() - startTime;
            this.logger.error("Payload generation failed", { actionId, executionTime }, error);
            return {
                timestamp: new Date().toISOString(),
                success: false,
                error: {
                    name: error instanceof Error
                        ? error.constructor.name
                        : "PayloadGenerationError",
                    message: error.message || "Unknown error",
                },
                logs: [],
                executionTime,
                validation: { isValid: false, errors: [], warnings: [] },
            };
        }
    }
    async runGeneratePayloadWithSession(actionId, sessionData) {
        const executionId = this.logger.createExecutionContext(actionId);
        const startTime = Date.now();
        try {
            this.logger.logExecution(executionId, "Starting payload generation with session data", {
                actionId,
                sessionKeys: Object.keys(sessionData),
            });
            const step = this.config.steps.find((s) => s.action_id === actionId);
            if (!step) {
                const availableActions = this.config.steps.map((s) => s.action_id);
                throw new errors_1.ActionNotFoundError(actionId, availableActions);
            }
            const index = this.config.steps.findIndex((s) => s.action_id === actionId);
            // Deep clone to avoid mutations
            const defaultPayload = JSON.parse(JSON.stringify(step.mock.defaultPayload));
            const context = this.generateContext(step.action_id, step.api, sessionData);
            defaultPayload.context = context;
            const schema = (0, function_registry_1.getFunctionSchema)("generate");
            const code = MockRunner.decodeBase64(step.mock.generate);
            let helperLib = "";
            try {
                helperLib = MockRunner.decodeBase64(this.config.helperLib || "");
            }
            catch (e) {
                this.logger.error("Failed to decode helper library", { actionId }, e);
                helperLib = "";
            }
            // Combine helper library and main code
            const fullCode = helperLib + "\n" + code;
            const result = await this.getRunnerInstance().execute(fullCode, schema, [
                defaultPayload,
                sessionData,
            ]);
            const executionTime = Date.now() - startTime;
            this.logger.logExecution(executionId, "Payload generation with session data completed", {
                actionId,
                success: result.success,
                output: result.result,
                executionTime,
            });
            return result;
        }
        catch (error) {
            const executionTime = Date.now() - startTime;
            this.logger.error("Payload generation with session data failed", { actionId, executionTime }, error);
            return {
                timestamp: new Date().toISOString(),
                success: false,
                error: {
                    name: error instanceof Error
                        ? error.constructor.name
                        : "PayloadGenerationError",
                    message: error.message || "Unknown error",
                },
                logs: [],
                executionTime,
                validation: { isValid: false, errors: [], warnings: [] },
            };
        }
    }
    async runValidatePayload(actionId, targetPayload) {
        try {
            const step = this.config.steps.find((s) => s.action_id === actionId);
            if (!step) {
                throw new Error(`Action step with ID ${actionId} not found.`);
            }
            const index = this.config.steps.findIndex((s) => s.action_id === actionId);
            const schema = (0, function_registry_1.getFunctionSchema)("validate");
            const sessionData = await this.getSessionDataUpToStep(index);
            const result = await this.getRunnerInstance().execute(MockRunner.decodeBase64(step.mock.validate), schema, [targetPayload, sessionData]);
            return result;
        }
        catch (error) {
            return {
                timestamp: new Date().toISOString(),
                success: false,
                error: {
                    name: "PayloadValidationError",
                    message: error.message || "Unknown error",
                },
                logs: [],
                executionTime: 0,
                validation: { isValid: false, errors: [], warnings: [] },
            };
        }
    }
    async runValidatePayloadWithSession(actionId, targetPayload, sessionData) {
        try {
            const step = this.config.steps.find((s) => s.action_id === actionId);
            if (!step) {
                throw new Error(`Action step with ID ${actionId} not found.`);
            }
            const schema = (0, function_registry_1.getFunctionSchema)("validate");
            const result = await this.getRunnerInstance().execute(MockRunner.decodeBase64(step.mock.validate), schema, [targetPayload, sessionData]);
            return result;
        }
        catch (error) {
            return {
                timestamp: new Date().toISOString(),
                success: false,
                error: {
                    name: "PayloadValidationError",
                    message: error.message || "Unknown error",
                },
                logs: [],
                executionTime: 0,
                validation: { isValid: false, errors: [], warnings: [] },
            };
        }
    }
    async runMeetRequirements(actionId) {
        try {
            const step = this.config.steps.find((s) => s.action_id === actionId);
            if (!step) {
                throw new Error(`Action step with ID ${actionId} not found.`);
            }
            const index = this.config.steps.findIndex((s) => s.action_id === actionId);
            const schema = (0, function_registry_1.getFunctionSchema)("meetsRequirements");
            const sessionData = await this.getSessionDataUpToStep(index);
            const result = await this.getRunnerInstance().execute(MockRunner.decodeBase64(step.mock.requirements), schema, [sessionData]);
            return result;
        }
        catch (error) {
            return {
                timestamp: new Date().toISOString(),
                success: false,
                error: {
                    name: "MeetRequirementsError",
                    message: error.message || "Unknown error",
                },
                logs: [],
                executionTime: 0,
                validation: { isValid: false, errors: [], warnings: [] },
            };
        }
    }
    async runMeetRequirementsWithSession(actionId, sessionData) {
        try {
            const step = this.config.steps.find((s) => s.action_id === actionId);
            if (!step) {
                throw new Error(`Action step with ID ${actionId} not found.`);
            }
            const schema = (0, function_registry_1.getFunctionSchema)("meetsRequirements");
            const result = await this.getRunnerInstance().execute(MockRunner.decodeBase64(step.mock.requirements), schema, [sessionData]);
            return result;
        }
        catch (error) {
            return {
                timestamp: new Date().toISOString(),
                success: false,
                error: {
                    name: "MeetRequirementsError",
                    message: error.message || "Unknown error",
                },
                logs: [],
                executionTime: 0,
                validation: { isValid: false, errors: [], warnings: [] },
            };
        }
    }
    getDefaultStep(api, actionId) {
        return {
            api: api,
            action_id: actionId,
            owner: api.startsWith("on_") ? "BPP" : "BAP",
            responseFor: null,
            unsolicited: false,
            description: "please add relevant description",
            mock: {
                generate: MockRunner.encodeBase64((0, function_registry_1.getFunctionSchema)("generate").template((0, function_registry_1.getFunctionSchema)("generate").defaultBody)),
                validate: MockRunner.encodeBase64((0, function_registry_1.getFunctionSchema)("validate").template((0, function_registry_1.getFunctionSchema)("validate").defaultBody)),
                requirements: MockRunner.encodeBase64((0, function_registry_1.getFunctionSchema)("meetsRequirements").template((0, function_registry_1.getFunctionSchema)("meetsRequirements").defaultBody)),
                defaultPayload: {
                    context: this.generateContext(actionId, api),
                    message: {},
                },
                saveData: {
                    transactionId: "$.context.transaction_id",
                    latestMessage_id: "$.context.message_id",
                    latestTimestamp: "$.context.timestamp",
                    bapId: "$.context.bap_id",
                    bapUri: "$.context.bap_uri",
                    bppId: "$.context.bpp_id",
                    bppUri: "$.context.bpp_uri",
                },
                inputs: {
                    id: "ExampleInputId",
                    jsonSchema: {
                        $schema: "http://json-schema.org/draft-07/schema#",
                        type: "object",
                        properties: {
                            email: {
                                type: "string",
                                format: "email",
                                minLength: 5,
                                maxLength: 50,
                                description: "User's email address",
                            },
                            age: {
                                type: "integer",
                                minimum: 18,
                                maximum: 120,
                                description: "User's age",
                            },
                            password: {
                                type: "string",
                                minLength: 8,
                                pattern: "^(?=.*[A-Z])(?=.*[0-9]).+$",
                                description: "Must contain uppercase and number",
                            },
                            website: {
                                type: "string",
                                format: "uri",
                            },
                            country: {
                                type: "string",
                                enum: ["US", "UK", "CA", "AU"],
                            },
                        },
                        required: ["email", "password"],
                        additionalProperties: false,
                    },
                },
            },
        };
    }
    generateContext(actionId, action, sessionData) {
        // Find the step configuration for this action
        const step = this.config.steps.find((s) => s.action_id === actionId);
        // Determine the message_id based on responseFor logic
        let messageId = (0, uuid_1.v4)();
        if (step?.responseFor) {
            // Priority 1: Get from sessionData if available
            if (sessionData?.latestMessage_id &&
                Array.isArray(sessionData.latestMessage_id) &&
                sessionData.latestMessage_id.length > 0) {
                messageId = sessionData.latestMessage_id[0];
            }
            // Priority 2: Fall back to transaction history
            else {
                const historyItem = this.config.transaction_history?.find((item) => item.action_id === step.responseFor);
                if (historyItem?.payload?.context?.message_id) {
                    messageId = historyItem.payload.context.message_id;
                }
            }
        }
        // Safely extract transaction_id
        const transactionId = (() => {
            // Priority 1: Get from sessionData
            if (sessionData?.transaction_id) {
                const sessionTxnId = Array.isArray(sessionData.transaction_id)
                    ? sessionData.transaction_id[0]
                    : sessionData.transaction_id;
                // Only return if we got a valid non-empty value
                if (sessionTxnId && sessionTxnId.trim().length > 0) {
                    return sessionTxnId;
                }
            }
            // Priority 2: Get from transaction history (most recent)
            if (this.config.transaction_history?.length > 0) {
                const mostRecentHistory = this.config.transaction_history[this.config.transaction_history.length - 1];
                const historyTxnId = mostRecentHistory?.payload?.context?.transaction_id;
                if (historyTxnId && historyTxnId.trim().length > 0) {
                    return historyTxnId;
                }
            }
            // Priority 3: Get from transaction_data
            const configTxnId = this.config.transaction_data?.transaction_id;
            if (configTxnId && configTxnId.trim().length > 0) {
                return configTxnId;
            }
            // Priority 4: Generate new UUID as last resort
            return (0, uuid_1.v4)();
        })();
        // Build base context
        const baseContext = {
            domain: this.config.meta?.domain || "",
            action: action,
            timestamp: new Date().toISOString(),
            transaction_id: transactionId,
            message_id: messageId,
            bap_id: this.config.transaction_data?.bap_id || "",
            bap_uri: this.config.transaction_data?.bap_uri || "",
            ttl: "PT30S",
        };
        // Add BPP details for non-search actions
        if (action !== "search") {
            baseContext.bpp_id = this.config.transaction_data?.bpp_id || "";
            baseContext.bpp_uri = this.config.transaction_data?.bpp_uri || "";
        }
        // Version-specific context structure
        const version = this.config.meta?.version || "2.0.0";
        const majorVersion = parseInt(version.split(".")[0], 10);
        if (majorVersion === 1) {
            return {
                ...baseContext,
                country: "IND",
                city: "*",
                core_version: version,
            };
        }
        // Version 2+ format
        return {
            ...baseContext,
            version: version,
            location: {
                country: {
                    code: "IND",
                },
                city: {
                    code: "*",
                },
            },
        };
    }
    async getSessionDataUpToStep(index) {
        const config = this.config;
        if (index < 0 || index > config.steps.length) {
            this.logger.warn("Invalid step index for session data", {
                index,
                maxSteps: config.steps.length,
            });
            return {};
        }
        if (config.transaction_history.length < index) {
            this.logger.error("Insufficient transaction history", {
                historyLength: config.transaction_history.length,
                requiredIndex: index,
            });
            throw new errors_1.SessionDataError(`Transaction history length (${config.transaction_history.length}) is less than step index (${index})`, index);
        }
        const sessionData = {};
        for (let i = 0; i < index; i++) {
            const histItem = config.transaction_history[i] ?? {
                payload: {},
            };
            const saveData = config.steps[i]?.mock.saveData ?? {};
            for (const key in saveData) {
                const path = saveData[key];
                const isAppend = key.startsWith("APPEND#");
                const isEval = path.startsWith("EVAL#");
                const evalExpression = isEval ? path.split("#")[1] : undefined;
                const actualKey = isAppend ? key.split("#")[1] : key;
                const actualPath = isEval ? path.split("#")[1] : path;
                try {
                    // Validate JSONPath expression
                    if (!path || typeof path !== "string") {
                        this.logger.warn("Invalid JSONPath expression", {
                            step: i,
                            key,
                            path,
                        });
                        continue;
                    }
                    const values = evalExpression
                        ? (await MockRunner.runGetSave(histItem.payload, evalExpression))
                            .result
                        : jsonpath_1.default.query(histItem.payload, actualPath);
                    if (values !== undefined) {
                        sessionData[actualKey] = isAppend
                            ? (sessionData[actualKey] || []).concat(values)
                            : values;
                        this.logger.debug("Session data extracted", {
                            step: i,
                            key,
                            path,
                            hasValue: true,
                        });
                    }
                    else {
                        this.logger.debug("No value found for JSONPath", {
                            step: i,
                            key,
                            path,
                        });
                        sessionData[actualKey] = null;
                    }
                }
                catch (error) {
                    this.logger.error("JSONPath query failed", { step: i, key, path }, error);
                    throw new errors_1.SessionDataError(`Failed to extract session data at step ${i}, key '${key}' with path '${path}': ${error.message}`, i, path);
                }
            }
        }
        this.logger.debug("Session data compiled", {
            stepIndex: index,
            keysExtracted: Object.keys(sessionData),
        });
        return sessionData;
    }
    static async runGetSave(payload, expression) {
        const evalExpression = MockRunner.decodeBase64(expression);
        const runner = runner_factory_1.RunnerFactory.createRunner();
        const schema = (0, function_registry_1.getFunctionSchema)("getSave");
        return await runner.execute(evalExpression, schema, [payload]);
    }
    static encodeBase64(input) {
        const bytes = new TextEncoder().encode(input);
        return btoa(String.fromCharCode(...bytes));
    }
    static decodeBase64(encoded) {
        const binaryString = atob(encoded);
        const bytes = new Uint8Array([...binaryString].map((char) => char.charCodeAt(0)));
        return new TextDecoder().decode(bytes);
    }
}
exports.MockRunner = MockRunner;
