"use strict";
/**
 * Performance monitoring utilities for MockRunner
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerformanceMonitor = void 0;
class PerformanceMonitor {
    constructor() {
        this.metrics = [];
        this.maxMetrics = 1000;
    }
    static getInstance() {
        if (!PerformanceMonitor.instance) {
            PerformanceMonitor.instance = new PerformanceMonitor();
        }
        return PerformanceMonitor.instance;
    }
    recordMetric(metric) {
        this.metrics.push({
            ...metric,
            memoryUsage: process.memoryUsage(),
            timestamp: new Date().toISOString(),
        });
        // Keep only recent metrics
        if (this.metrics.length > this.maxMetrics) {
            this.metrics = this.metrics.slice(-this.maxMetrics);
        }
    }
    getMetrics(operationType) {
        if (operationType) {
            return this.metrics.filter((m) => m.operationType === operationType);
        }
        return [...this.metrics];
    }
    getAverageExecutionTime(operationType) {
        const relevantMetrics = this.getMetrics(operationType);
        if (relevantMetrics.length === 0)
            return 0;
        const total = relevantMetrics.reduce((sum, metric) => sum + metric.executionTime, 0);
        return total / relevantMetrics.length;
    }
    getSlowOperations(thresholdMs = 1000) {
        return this.metrics.filter((metric) => metric.executionTime > thresholdMs);
    }
    getSummary() {
        const totalOps = this.metrics.length;
        const avgTime = totalOps > 0
            ? this.metrics.reduce((sum, m) => sum + m.executionTime, 0) / totalOps
            : 0;
        const slowOps = this.getSlowOperations().length;
        const successfulOps = this.metrics.filter((m) => m.success).length;
        const successRate = totalOps > 0 ? (successfulOps / totalOps) * 100 : 0;
        // Simple memory trend analysis
        let memoryTrend = "stable";
        if (this.metrics.length > 10) {
            const recentMetrics = this.metrics.slice(-10);
            const firstMemory = recentMetrics[0]?.memoryUsage?.heapUsed || 0;
            const lastMemory = recentMetrics[recentMetrics.length - 1]?.memoryUsage?.heapUsed || 0;
            const diff = lastMemory - firstMemory;
            const threshold = firstMemory * 0.1; // 10% threshold
            if (diff > threshold) {
                memoryTrend = "increasing";
            }
            else if (diff < -threshold) {
                memoryTrend = "decreasing";
            }
        }
        return {
            totalOperations: totalOps,
            averageExecutionTime: Math.round(avgTime * 100) / 100,
            slowOperations: slowOps,
            successRate: Math.round(successRate * 100) / 100,
            memoryTrend,
        };
    }
    clearMetrics() {
        this.metrics = [];
    }
    // Helper method to create performance timer
    createTimer(operationType, actionId) {
        const startTime = Date.now();
        return {
            finish: (success, codeComplexity) => {
                const executionTime = Date.now() - startTime;
                this.recordMetric({
                    operationType,
                    actionId,
                    executionTime,
                    success,
                    codeComplexity,
                    timestamp: new Date().toISOString(),
                });
                return executionTime;
            },
        };
    }
}
exports.PerformanceMonitor = PerformanceMonitor;
